// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dragon.proto

#ifndef PROTOBUF_dragon_2eproto__INCLUDED
#define PROTOBUF_dragon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dragon_2eproto();
void protobuf_AssignDesc_dragon_2eproto();
void protobuf_ShutdownFile_dragon_2eproto();

class TensorProto;
class TensorProtos;
class Argument;
class DeviceOption;
class OperatorDef;
class GradientTarget;
class UpdateTarget;
class TensorFiller;
class GraphDef;

enum TensorProto_DataType {
  TensorProto_DataType_FLOAT = 1,
  TensorProto_DataType_INT32 = 2,
  TensorProto_DataType_BYTE = 3,
  TensorProto_DataType_STRING = 4,
  TensorProto_DataType_FLOAT16 = 12
};
bool TensorProto_DataType_IsValid(int value);
const TensorProto_DataType TensorProto_DataType_DataType_MIN = TensorProto_DataType_FLOAT;
const TensorProto_DataType TensorProto_DataType_DataType_MAX = TensorProto_DataType_FLOAT16;
const int TensorProto_DataType_DataType_ARRAYSIZE = TensorProto_DataType_DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TensorProto_DataType_descriptor();
inline const ::std::string& TensorProto_DataType_Name(TensorProto_DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TensorProto_DataType_descriptor(), value);
}
inline bool TensorProto_DataType_Parse(
    const ::std::string& name, TensorProto_DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TensorProto_DataType>(
    TensorProto_DataType_descriptor(), name, value);
}
enum TensorFiller_VarianceNorm {
  TensorFiller_VarianceNorm_FAN_IN = 0,
  TensorFiller_VarianceNorm_FAN_OUT = 1,
  TensorFiller_VarianceNorm_FAN_AVG = 2
};
bool TensorFiller_VarianceNorm_IsValid(int value);
const TensorFiller_VarianceNorm TensorFiller_VarianceNorm_VarianceNorm_MIN = TensorFiller_VarianceNorm_FAN_IN;
const TensorFiller_VarianceNorm TensorFiller_VarianceNorm_VarianceNorm_MAX = TensorFiller_VarianceNorm_FAN_AVG;
const int TensorFiller_VarianceNorm_VarianceNorm_ARRAYSIZE = TensorFiller_VarianceNorm_VarianceNorm_MAX + 1;

const ::google::protobuf::EnumDescriptor* TensorFiller_VarianceNorm_descriptor();
inline const ::std::string& TensorFiller_VarianceNorm_Name(TensorFiller_VarianceNorm value) {
  return ::google::protobuf::internal::NameOfEnum(
    TensorFiller_VarianceNorm_descriptor(), value);
}
inline bool TensorFiller_VarianceNorm_Parse(
    const ::std::string& name, TensorFiller_VarianceNorm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TensorFiller_VarianceNorm>(
    TensorFiller_VarianceNorm_descriptor(), name, value);
}
enum DeviceType {
  CPU = 0,
  CUDA = 1,
  OPENCL = 2
};
bool DeviceType_IsValid(int value);
const DeviceType DeviceType_MIN = CPU;
const DeviceType DeviceType_MAX = OPENCL;
const int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceType_descriptor();
inline const ::std::string& DeviceType_Name(DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceType_descriptor(), value);
}
inline bool DeviceType_Parse(
    const ::std::string& name, DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
// ===================================================================

class TensorProto : public ::google::protobuf::Message {
 public:
  TensorProto();
  virtual ~TensorProto();

  TensorProto(const TensorProto& from);

  inline TensorProto& operator=(const TensorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorProto& default_instance();

  void Swap(TensorProto* other);

  // implements Message ----------------------------------------------

  TensorProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TensorProto& from);
  void MergeFrom(const TensorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TensorProto_DataType DataType;
  static const DataType FLOAT = TensorProto_DataType_FLOAT;
  static const DataType INT32 = TensorProto_DataType_INT32;
  static const DataType BYTE = TensorProto_DataType_BYTE;
  static const DataType STRING = TensorProto_DataType_STRING;
  static const DataType FLOAT16 = TensorProto_DataType_FLOAT16;
  static inline bool DataType_IsValid(int value) {
    return TensorProto_DataType_IsValid(value);
  }
  static const DataType DataType_MIN =
    TensorProto_DataType_DataType_MIN;
  static const DataType DataType_MAX =
    TensorProto_DataType_DataType_MAX;
  static const int DataType_ARRAYSIZE =
    TensorProto_DataType_DataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DataType_descriptor() {
    return TensorProto_DataType_descriptor();
  }
  static inline const ::std::string& DataType_Name(DataType value) {
    return TensorProto_DataType_Name(value);
  }
  static inline bool DataType_Parse(const ::std::string& name,
      DataType* value) {
    return TensorProto_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int32 dims = 1;
  inline int dims_size() const;
  inline void clear_dims();
  static const int kDimsFieldNumber = 1;
  inline ::google::protobuf::int32 dims(int index) const;
  inline void set_dims(int index, ::google::protobuf::int32 value);
  inline void add_dims(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dims() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dims();

  // optional .TensorProto.DataType data_type = 2 [default = FLOAT];
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 2;
  inline ::TensorProto_DataType data_type() const;
  inline void set_data_type(::TensorProto_DataType value);

  // repeated float float_data = 3 [packed = true];
  inline int float_data_size() const;
  inline void clear_float_data();
  static const int kFloatDataFieldNumber = 3;
  inline float float_data(int index) const;
  inline void set_float_data(int index, float value);
  inline void add_float_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      float_data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_float_data();

  // repeated int32 int32_data = 4 [packed = true];
  inline int int32_data_size() const;
  inline void clear_int32_data();
  static const int kInt32DataFieldNumber = 4;
  inline ::google::protobuf::int32 int32_data(int index) const;
  inline void set_int32_data(int index, ::google::protobuf::int32 value);
  inline void add_int32_data(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      int32_data() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_int32_data();

  // optional bytes byte_data = 5;
  inline bool has_byte_data() const;
  inline void clear_byte_data();
  static const int kByteDataFieldNumber = 5;
  inline const ::std::string& byte_data() const;
  inline void set_byte_data(const ::std::string& value);
  inline void set_byte_data(const char* value);
  inline void set_byte_data(const void* value, size_t size);
  inline ::std::string* mutable_byte_data();
  inline ::std::string* release_byte_data();
  inline void set_allocated_byte_data(::std::string* byte_data);

  // repeated bytes string_data = 6;
  inline int string_data_size() const;
  inline void clear_string_data();
  static const int kStringDataFieldNumber = 6;
  inline const ::std::string& string_data(int index) const;
  inline ::std::string* mutable_string_data(int index);
  inline void set_string_data(int index, const ::std::string& value);
  inline void set_string_data(int index, const char* value);
  inline void set_string_data(int index, const void* value, size_t size);
  inline ::std::string* add_string_data();
  inline void add_string_data(const ::std::string& value);
  inline void add_string_data(const char* value);
  inline void add_string_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& string_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_string_data();

  // optional string name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:TensorProto)
 private:
  inline void set_has_data_type();
  inline void clear_has_data_type();
  inline void set_has_byte_data();
  inline void clear_has_byte_data();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dims_;
  ::google::protobuf::RepeatedField< float > float_data_;
  mutable int _float_data_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > int32_data_;
  mutable int _int32_data_cached_byte_size_;
  ::std::string* byte_data_;
  ::google::protobuf::RepeatedPtrField< ::std::string> string_data_;
  ::std::string* name_;
  int data_type_;
  friend void  protobuf_AddDesc_dragon_2eproto();
  friend void protobuf_AssignDesc_dragon_2eproto();
  friend void protobuf_ShutdownFile_dragon_2eproto();

  void InitAsDefaultInstance();
  static TensorProto* default_instance_;
};
// -------------------------------------------------------------------

class TensorProtos : public ::google::protobuf::Message {
 public:
  TensorProtos();
  virtual ~TensorProtos();

  TensorProtos(const TensorProtos& from);

  inline TensorProtos& operator=(const TensorProtos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorProtos& default_instance();

  void Swap(TensorProtos* other);

  // implements Message ----------------------------------------------

  TensorProtos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TensorProtos& from);
  void MergeFrom(const TensorProtos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TensorProto protos = 1;
  inline int protos_size() const;
  inline void clear_protos();
  static const int kProtosFieldNumber = 1;
  inline const ::TensorProto& protos(int index) const;
  inline ::TensorProto* mutable_protos(int index);
  inline ::TensorProto* add_protos();
  inline const ::google::protobuf::RepeatedPtrField< ::TensorProto >&
      protos() const;
  inline ::google::protobuf::RepeatedPtrField< ::TensorProto >*
      mutable_protos();

  // @@protoc_insertion_point(class_scope:TensorProtos)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TensorProto > protos_;
  friend void  protobuf_AddDesc_dragon_2eproto();
  friend void protobuf_AssignDesc_dragon_2eproto();
  friend void protobuf_ShutdownFile_dragon_2eproto();

  void InitAsDefaultInstance();
  static TensorProtos* default_instance_;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::Message {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();

  void Swap(Argument* other);

  // implements Message ----------------------------------------------

  Argument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional float f = 2;
  inline bool has_f() const;
  inline void clear_f();
  static const int kFFieldNumber = 2;
  inline float f() const;
  inline void set_f(float value);

  // optional int32 i = 3;
  inline bool has_i() const;
  inline void clear_i();
  static const int kIFieldNumber = 3;
  inline ::google::protobuf::int32 i() const;
  inline void set_i(::google::protobuf::int32 value);

  // optional int64 i64 = 9;
  inline bool has_i64() const;
  inline void clear_i64();
  static const int kI64FieldNumber = 9;
  inline ::google::protobuf::int64 i64() const;
  inline void set_i64(::google::protobuf::int64 value);

  // optional string s = 4;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 4;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // optional bool b = 8;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 8;
  inline bool b() const;
  inline void set_b(bool value);

  // repeated float floats = 5;
  inline int floats_size() const;
  inline void clear_floats();
  static const int kFloatsFieldNumber = 5;
  inline float floats(int index) const;
  inline void set_floats(int index, float value);
  inline void add_floats(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      floats() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_floats();

  // repeated int32 ints = 6;
  inline int ints_size() const;
  inline void clear_ints();
  static const int kIntsFieldNumber = 6;
  inline ::google::protobuf::int32 ints(int index) const;
  inline void set_ints(int index, ::google::protobuf::int32 value);
  inline void add_ints(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ints() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ints();

  // repeated string strings = 7;
  inline int strings_size() const;
  inline void clear_strings();
  static const int kStringsFieldNumber = 7;
  inline const ::std::string& strings(int index) const;
  inline ::std::string* mutable_strings(int index);
  inline void set_strings(int index, const ::std::string& value);
  inline void set_strings(int index, const char* value);
  inline void set_strings(int index, const char* value, size_t size);
  inline ::std::string* add_strings();
  inline void add_strings(const ::std::string& value);
  inline void add_strings(const char* value);
  inline void add_strings(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& strings() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_strings();

  // @@protoc_insertion_point(class_scope:Argument)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_f();
  inline void clear_has_f();
  inline void set_has_i();
  inline void clear_has_i();
  inline void set_has_i64();
  inline void clear_has_i64();
  inline void set_has_s();
  inline void clear_has_s();
  inline void set_has_b();
  inline void clear_has_b();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  float f_;
  ::google::protobuf::int32 i_;
  ::google::protobuf::int64 i64_;
  ::std::string* s_;
  ::google::protobuf::RepeatedField< float > floats_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ints_;
  ::google::protobuf::RepeatedPtrField< ::std::string> strings_;
  bool b_;
  friend void  protobuf_AddDesc_dragon_2eproto();
  friend void protobuf_AssignDesc_dragon_2eproto();
  friend void protobuf_ShutdownFile_dragon_2eproto();

  void InitAsDefaultInstance();
  static Argument* default_instance_;
};
// -------------------------------------------------------------------

class DeviceOption : public ::google::protobuf::Message {
 public:
  DeviceOption();
  virtual ~DeviceOption();

  DeviceOption(const DeviceOption& from);

  inline DeviceOption& operator=(const DeviceOption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceOption& default_instance();

  void Swap(DeviceOption* other);

  // implements Message ----------------------------------------------

  DeviceOption* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceOption& from);
  void MergeFrom(const DeviceOption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DeviceType device_type = 1 [default = CPU];
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  inline ::DeviceType device_type() const;
  inline void set_device_type(::DeviceType value);

  // optional int32 gpu_id = 2 [default = 0];
  inline bool has_gpu_id() const;
  inline void clear_gpu_id();
  static const int kGpuIdFieldNumber = 2;
  inline ::google::protobuf::int32 gpu_id() const;
  inline void set_gpu_id(::google::protobuf::int32 value);

  // optional uint32 random_seed = 3 [default = 3];
  inline bool has_random_seed() const;
  inline void clear_random_seed();
  static const int kRandomSeedFieldNumber = 3;
  inline ::google::protobuf::uint32 random_seed() const;
  inline void set_random_seed(::google::protobuf::uint32 value);

  // optional string engine = 4;
  inline bool has_engine() const;
  inline void clear_engine();
  static const int kEngineFieldNumber = 4;
  inline const ::std::string& engine() const;
  inline void set_engine(const ::std::string& value);
  inline void set_engine(const char* value);
  inline void set_engine(const char* value, size_t size);
  inline ::std::string* mutable_engine();
  inline ::std::string* release_engine();
  inline void set_allocated_engine(::std::string* engine);

  // @@protoc_insertion_point(class_scope:DeviceOption)
 private:
  inline void set_has_device_type();
  inline void clear_has_device_type();
  inline void set_has_gpu_id();
  inline void clear_has_gpu_id();
  inline void set_has_random_seed();
  inline void clear_has_random_seed();
  inline void set_has_engine();
  inline void clear_has_engine();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int device_type_;
  ::google::protobuf::int32 gpu_id_;
  ::std::string* engine_;
  ::google::protobuf::uint32 random_seed_;
  friend void  protobuf_AddDesc_dragon_2eproto();
  friend void protobuf_AssignDesc_dragon_2eproto();
  friend void protobuf_ShutdownFile_dragon_2eproto();

  void InitAsDefaultInstance();
  static DeviceOption* default_instance_;
};
// -------------------------------------------------------------------

class OperatorDef : public ::google::protobuf::Message {
 public:
  OperatorDef();
  virtual ~OperatorDef();

  OperatorDef(const OperatorDef& from);

  inline OperatorDef& operator=(const OperatorDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperatorDef& default_instance();

  void Swap(OperatorDef* other);

  // implements Message ----------------------------------------------

  OperatorDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperatorDef& from);
  void MergeFrom(const OperatorDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string input = 1;
  inline int input_size() const;
  inline void clear_input();
  static const int kInputFieldNumber = 1;
  inline const ::std::string& input(int index) const;
  inline ::std::string* mutable_input(int index);
  inline void set_input(int index, const ::std::string& value);
  inline void set_input(int index, const char* value);
  inline void set_input(int index, const char* value, size_t size);
  inline ::std::string* add_input();
  inline void add_input(const ::std::string& value);
  inline void add_input(const char* value);
  inline void add_input(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();

  // repeated string output = 2;
  inline int output_size() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 2;
  inline const ::std::string& output(int index) const;
  inline ::std::string* mutable_output(int index);
  inline void set_output(int index, const ::std::string& value);
  inline void set_output(int index, const char* value);
  inline void set_output(int index, const char* value, size_t size);
  inline ::std::string* add_output();
  inline void add_output(const ::std::string& value);
  inline void add_output(const char* value);
  inline void add_output(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& output() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_output();

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // repeated .Argument arg = 5;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 5;
  inline const ::Argument& arg(int index) const;
  inline ::Argument* mutable_arg(int index);
  inline ::Argument* add_arg();
  inline const ::google::protobuf::RepeatedPtrField< ::Argument >&
      arg() const;
  inline ::google::protobuf::RepeatedPtrField< ::Argument >*
      mutable_arg();

  // optional .DeviceOption device_option = 6;
  inline bool has_device_option() const;
  inline void clear_device_option();
  static const int kDeviceOptionFieldNumber = 6;
  inline const ::DeviceOption& device_option() const;
  inline ::DeviceOption* mutable_device_option();
  inline ::DeviceOption* release_device_option();
  inline void set_allocated_device_option(::DeviceOption* device_option);

  // optional bool debug_mode = 7 [default = false];
  inline bool has_debug_mode() const;
  inline void clear_debug_mode();
  static const int kDebugModeFieldNumber = 7;
  inline bool debug_mode() const;
  inline void set_debug_mode(bool value);

  // optional bool share_grads = 8 [default = false];
  inline bool has_share_grads() const;
  inline void clear_share_grads();
  static const int kShareGradsFieldNumber = 8;
  inline bool share_grads() const;
  inline void set_share_grads(bool value);

  // @@protoc_insertion_point(class_scope:OperatorDef)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_device_option();
  inline void clear_has_device_option();
  inline void set_has_debug_mode();
  inline void clear_has_debug_mode();
  inline void set_has_share_grads();
  inline void clear_has_share_grads();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  ::google::protobuf::RepeatedPtrField< ::std::string> output_;
  ::std::string* name_;
  ::std::string* type_;
  ::google::protobuf::RepeatedPtrField< ::Argument > arg_;
  ::DeviceOption* device_option_;
  bool debug_mode_;
  bool share_grads_;
  friend void  protobuf_AddDesc_dragon_2eproto();
  friend void protobuf_AssignDesc_dragon_2eproto();
  friend void protobuf_ShutdownFile_dragon_2eproto();

  void InitAsDefaultInstance();
  static OperatorDef* default_instance_;
};
// -------------------------------------------------------------------

class GradientTarget : public ::google::protobuf::Message {
 public:
  GradientTarget();
  virtual ~GradientTarget();

  GradientTarget(const GradientTarget& from);

  inline GradientTarget& operator=(const GradientTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GradientTarget& default_instance();

  void Swap(GradientTarget* other);

  // implements Message ----------------------------------------------

  GradientTarget* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GradientTarget& from);
  void MergeFrom(const GradientTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cost = 1;
  inline bool has_cost() const;
  inline void clear_cost();
  static const int kCostFieldNumber = 1;
  inline const ::std::string& cost() const;
  inline void set_cost(const ::std::string& value);
  inline void set_cost(const char* value);
  inline void set_cost(const char* value, size_t size);
  inline ::std::string* mutable_cost();
  inline ::std::string* release_cost();
  inline void set_allocated_cost(::std::string* cost);

  // optional string wrt = 2;
  inline bool has_wrt() const;
  inline void clear_wrt();
  static const int kWrtFieldNumber = 2;
  inline const ::std::string& wrt() const;
  inline void set_wrt(const ::std::string& value);
  inline void set_wrt(const char* value);
  inline void set_wrt(const char* value, size_t size);
  inline ::std::string* mutable_wrt();
  inline ::std::string* release_wrt();
  inline void set_allocated_wrt(::std::string* wrt);

  // optional string external = 3;
  inline bool has_external() const;
  inline void clear_external();
  static const int kExternalFieldNumber = 3;
  inline const ::std::string& external() const;
  inline void set_external(const ::std::string& value);
  inline void set_external(const char* value);
  inline void set_external(const char* value, size_t size);
  inline ::std::string* mutable_external();
  inline ::std::string* release_external();
  inline void set_allocated_external(::std::string* external);

  // @@protoc_insertion_point(class_scope:GradientTarget)
 private:
  inline void set_has_cost();
  inline void clear_has_cost();
  inline void set_has_wrt();
  inline void clear_has_wrt();
  inline void set_has_external();
  inline void clear_has_external();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* cost_;
  ::std::string* wrt_;
  ::std::string* external_;
  friend void  protobuf_AddDesc_dragon_2eproto();
  friend void protobuf_AssignDesc_dragon_2eproto();
  friend void protobuf_ShutdownFile_dragon_2eproto();

  void InitAsDefaultInstance();
  static GradientTarget* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTarget : public ::google::protobuf::Message {
 public:
  UpdateTarget();
  virtual ~UpdateTarget();

  UpdateTarget(const UpdateTarget& from);

  inline UpdateTarget& operator=(const UpdateTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTarget& default_instance();

  void Swap(UpdateTarget* other);

  // implements Message ----------------------------------------------

  UpdateTarget* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTarget& from);
  void MergeFrom(const UpdateTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // repeated string tensor = 3;
  inline int tensor_size() const;
  inline void clear_tensor();
  static const int kTensorFieldNumber = 3;
  inline const ::std::string& tensor(int index) const;
  inline ::std::string* mutable_tensor(int index);
  inline void set_tensor(int index, const ::std::string& value);
  inline void set_tensor(int index, const char* value);
  inline void set_tensor(int index, const char* value, size_t size);
  inline ::std::string* add_tensor();
  inline void add_tensor(const ::std::string& value);
  inline void add_tensor(const char* value);
  inline void add_tensor(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tensor() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tensor();

  // repeated .Argument arg = 4;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 4;
  inline const ::Argument& arg(int index) const;
  inline ::Argument* mutable_arg(int index);
  inline ::Argument* add_arg();
  inline const ::google::protobuf::RepeatedPtrField< ::Argument >&
      arg() const;
  inline ::google::protobuf::RepeatedPtrField< ::Argument >*
      mutable_arg();

  // @@protoc_insertion_point(class_scope:UpdateTarget)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tensor_;
  ::google::protobuf::RepeatedPtrField< ::Argument > arg_;
  friend void  protobuf_AddDesc_dragon_2eproto();
  friend void protobuf_AssignDesc_dragon_2eproto();
  friend void protobuf_ShutdownFile_dragon_2eproto();

  void InitAsDefaultInstance();
  static UpdateTarget* default_instance_;
};
// -------------------------------------------------------------------

class TensorFiller : public ::google::protobuf::Message {
 public:
  TensorFiller();
  virtual ~TensorFiller();

  TensorFiller(const TensorFiller& from);

  inline TensorFiller& operator=(const TensorFiller& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorFiller& default_instance();

  void Swap(TensorFiller* other);

  // implements Message ----------------------------------------------

  TensorFiller* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TensorFiller& from);
  void MergeFrom(const TensorFiller& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TensorFiller_VarianceNorm VarianceNorm;
  static const VarianceNorm FAN_IN = TensorFiller_VarianceNorm_FAN_IN;
  static const VarianceNorm FAN_OUT = TensorFiller_VarianceNorm_FAN_OUT;
  static const VarianceNorm FAN_AVG = TensorFiller_VarianceNorm_FAN_AVG;
  static inline bool VarianceNorm_IsValid(int value) {
    return TensorFiller_VarianceNorm_IsValid(value);
  }
  static const VarianceNorm VarianceNorm_MIN =
    TensorFiller_VarianceNorm_VarianceNorm_MIN;
  static const VarianceNorm VarianceNorm_MAX =
    TensorFiller_VarianceNorm_VarianceNorm_MAX;
  static const int VarianceNorm_ARRAYSIZE =
    TensorFiller_VarianceNorm_VarianceNorm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VarianceNorm_descriptor() {
    return TensorFiller_VarianceNorm_descriptor();
  }
  static inline const ::std::string& VarianceNorm_Name(VarianceNorm value) {
    return TensorFiller_VarianceNorm_Name(value);
  }
  static inline bool VarianceNorm_Parse(const ::std::string& name,
      VarianceNorm* value) {
    return TensorFiller_VarianceNorm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string tensor = 1;
  inline bool has_tensor() const;
  inline void clear_tensor();
  static const int kTensorFieldNumber = 1;
  inline const ::std::string& tensor() const;
  inline void set_tensor(const ::std::string& value);
  inline void set_tensor(const char* value);
  inline void set_tensor(const char* value, size_t size);
  inline ::std::string* mutable_tensor();
  inline ::std::string* release_tensor();
  inline void set_allocated_tensor(::std::string* tensor);

  // optional string type = 2 [default = "constant"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional float value = 3 [default = 0];
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline float value() const;
  inline void set_value(float value);

  // optional float low = 4 [default = 0];
  inline bool has_low() const;
  inline void clear_low();
  static const int kLowFieldNumber = 4;
  inline float low() const;
  inline void set_low(float value);

  // optional float high = 5 [default = 1];
  inline bool has_high() const;
  inline void clear_high();
  static const int kHighFieldNumber = 5;
  inline float high() const;
  inline void set_high(float value);

  // optional float mean = 6 [default = 0];
  inline bool has_mean() const;
  inline void clear_mean();
  static const int kMeanFieldNumber = 6;
  inline float mean() const;
  inline void set_mean(float value);

  // optional float std = 7 [default = 1];
  inline bool has_std() const;
  inline void clear_std();
  static const int kStdFieldNumber = 7;
  inline float std() const;
  inline void set_std(float value);

  // optional float scale = 8 [default = 3];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 8;
  inline float scale() const;
  inline void set_scale(float value);

  // optional .TensorFiller.VarianceNorm variance_norm = 9 [default = FAN_IN];
  inline bool has_variance_norm() const;
  inline void clear_variance_norm();
  static const int kVarianceNormFieldNumber = 9;
  inline ::TensorFiller_VarianceNorm variance_norm() const;
  inline void set_variance_norm(::TensorFiller_VarianceNorm value);

  // @@protoc_insertion_point(class_scope:TensorFiller)
 private:
  inline void set_has_tensor();
  inline void clear_has_tensor();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_low();
  inline void clear_has_low();
  inline void set_has_high();
  inline void clear_has_high();
  inline void set_has_mean();
  inline void clear_has_mean();
  inline void set_has_std();
  inline void clear_has_std();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_variance_norm();
  inline void clear_has_variance_norm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tensor_;
  static ::std::string* _default_type_;
  ::std::string* type_;
  float value_;
  float low_;
  float high_;
  float mean_;
  float std_;
  float scale_;
  int variance_norm_;
  friend void  protobuf_AddDesc_dragon_2eproto();
  friend void protobuf_AssignDesc_dragon_2eproto();
  friend void protobuf_ShutdownFile_dragon_2eproto();

  void InitAsDefaultInstance();
  static TensorFiller* default_instance_;
};
// -------------------------------------------------------------------

class GraphDef : public ::google::protobuf::Message {
 public:
  GraphDef();
  virtual ~GraphDef();

  GraphDef(const GraphDef& from);

  inline GraphDef& operator=(const GraphDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GraphDef& default_instance();

  void Swap(GraphDef* other);

  // implements Message ----------------------------------------------

  GraphDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GraphDef& from);
  void MergeFrom(const GraphDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .OperatorDef op = 2;
  inline int op_size() const;
  inline void clear_op();
  static const int kOpFieldNumber = 2;
  inline const ::OperatorDef& op(int index) const;
  inline ::OperatorDef* mutable_op(int index);
  inline ::OperatorDef* add_op();
  inline const ::google::protobuf::RepeatedPtrField< ::OperatorDef >&
      op() const;
  inline ::google::protobuf::RepeatedPtrField< ::OperatorDef >*
      mutable_op();

  // optional string graph_type = 3;
  inline bool has_graph_type() const;
  inline void clear_graph_type();
  static const int kGraphTypeFieldNumber = 3;
  inline const ::std::string& graph_type() const;
  inline void set_graph_type(const ::std::string& value);
  inline void set_graph_type(const char* value);
  inline void set_graph_type(const char* value, size_t size);
  inline ::std::string* mutable_graph_type();
  inline ::std::string* release_graph_type();
  inline void set_allocated_graph_type(::std::string* graph_type);

  // optional .DeviceOption device_option = 5;
  inline bool has_device_option() const;
  inline void clear_device_option();
  static const int kDeviceOptionFieldNumber = 5;
  inline const ::DeviceOption& device_option() const;
  inline ::DeviceOption* mutable_device_option();
  inline ::DeviceOption* release_device_option();
  inline void set_allocated_device_option(::DeviceOption* device_option);

  // repeated .Argument arg = 6;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 6;
  inline const ::Argument& arg(int index) const;
  inline ::Argument* mutable_arg(int index);
  inline ::Argument* add_arg();
  inline const ::google::protobuf::RepeatedPtrField< ::Argument >&
      arg() const;
  inline ::google::protobuf::RepeatedPtrField< ::Argument >*
      mutable_arg();

  // repeated string target = 7;
  inline int target_size() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 7;
  inline const ::std::string& target(int index) const;
  inline ::std::string* mutable_target(int index);
  inline void set_target(int index, const ::std::string& value);
  inline void set_target(int index, const char* value);
  inline void set_target(int index, const char* value, size_t size);
  inline ::std::string* add_target();
  inline void add_target(const ::std::string& value);
  inline void add_target(const char* value);
  inline void add_target(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& target() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_target();

  // repeated .GradientTarget g_target = 8;
  inline int g_target_size() const;
  inline void clear_g_target();
  static const int kGTargetFieldNumber = 8;
  inline const ::GradientTarget& g_target(int index) const;
  inline ::GradientTarget* mutable_g_target(int index);
  inline ::GradientTarget* add_g_target();
  inline const ::google::protobuf::RepeatedPtrField< ::GradientTarget >&
      g_target() const;
  inline ::google::protobuf::RepeatedPtrField< ::GradientTarget >*
      mutable_g_target();

  // repeated .UpdateTarget u_target = 9;
  inline int u_target_size() const;
  inline void clear_u_target();
  static const int kUTargetFieldNumber = 9;
  inline const ::UpdateTarget& u_target(int index) const;
  inline ::UpdateTarget* mutable_u_target(int index);
  inline ::UpdateTarget* add_u_target();
  inline const ::google::protobuf::RepeatedPtrField< ::UpdateTarget >&
      u_target() const;
  inline ::google::protobuf::RepeatedPtrField< ::UpdateTarget >*
      mutable_u_target();

  // optional bool debug_mode = 10 [default = false];
  inline bool has_debug_mode() const;
  inline void clear_debug_mode();
  static const int kDebugModeFieldNumber = 10;
  inline bool debug_mode() const;
  inline void set_debug_mode(bool value);

  // optional bool share_grads = 11 [default = false];
  inline bool has_share_grads() const;
  inline void clear_share_grads();
  static const int kShareGradsFieldNumber = 11;
  inline bool share_grads() const;
  inline void set_share_grads(bool value);

  // @@protoc_insertion_point(class_scope:GraphDef)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_graph_type();
  inline void clear_has_graph_type();
  inline void set_has_device_option();
  inline void clear_has_device_option();
  inline void set_has_debug_mode();
  inline void clear_has_debug_mode();
  inline void set_has_share_grads();
  inline void clear_has_share_grads();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::OperatorDef > op_;
  ::std::string* graph_type_;
  ::DeviceOption* device_option_;
  ::google::protobuf::RepeatedPtrField< ::Argument > arg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> target_;
  ::google::protobuf::RepeatedPtrField< ::GradientTarget > g_target_;
  ::google::protobuf::RepeatedPtrField< ::UpdateTarget > u_target_;
  bool debug_mode_;
  bool share_grads_;
  friend void  protobuf_AddDesc_dragon_2eproto();
  friend void protobuf_AssignDesc_dragon_2eproto();
  friend void protobuf_ShutdownFile_dragon_2eproto();

  void InitAsDefaultInstance();
  static GraphDef* default_instance_;
};
// ===================================================================


// ===================================================================

// TensorProto

// repeated int32 dims = 1;
inline int TensorProto::dims_size() const {
  return dims_.size();
}
inline void TensorProto::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int32 TensorProto::dims(int index) const {
  // @@protoc_insertion_point(field_get:TensorProto.dims)
  return dims_.Get(index);
}
inline void TensorProto::set_dims(int index, ::google::protobuf::int32 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:TensorProto.dims)
}
inline void TensorProto::add_dims(::google::protobuf::int32 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:TensorProto.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorProto::dims() const {
  // @@protoc_insertion_point(field_list:TensorProto.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorProto::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:TensorProto.dims)
  return &dims_;
}

// optional .TensorProto.DataType data_type = 2 [default = FLOAT];
inline bool TensorProto::has_data_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TensorProto::set_has_data_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TensorProto::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TensorProto::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline ::TensorProto_DataType TensorProto::data_type() const {
  // @@protoc_insertion_point(field_get:TensorProto.data_type)
  return static_cast< ::TensorProto_DataType >(data_type_);
}
inline void TensorProto::set_data_type(::TensorProto_DataType value) {
  assert(::TensorProto_DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:TensorProto.data_type)
}

// repeated float float_data = 3 [packed = true];
inline int TensorProto::float_data_size() const {
  return float_data_.size();
}
inline void TensorProto::clear_float_data() {
  float_data_.Clear();
}
inline float TensorProto::float_data(int index) const {
  // @@protoc_insertion_point(field_get:TensorProto.float_data)
  return float_data_.Get(index);
}
inline void TensorProto::set_float_data(int index, float value) {
  float_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:TensorProto.float_data)
}
inline void TensorProto::add_float_data(float value) {
  float_data_.Add(value);
  // @@protoc_insertion_point(field_add:TensorProto.float_data)
}
inline const ::google::protobuf::RepeatedField< float >&
TensorProto::float_data() const {
  // @@protoc_insertion_point(field_list:TensorProto.float_data)
  return float_data_;
}
inline ::google::protobuf::RepeatedField< float >*
TensorProto::mutable_float_data() {
  // @@protoc_insertion_point(field_mutable_list:TensorProto.float_data)
  return &float_data_;
}

// repeated int32 int32_data = 4 [packed = true];
inline int TensorProto::int32_data_size() const {
  return int32_data_.size();
}
inline void TensorProto::clear_int32_data() {
  int32_data_.Clear();
}
inline ::google::protobuf::int32 TensorProto::int32_data(int index) const {
  // @@protoc_insertion_point(field_get:TensorProto.int32_data)
  return int32_data_.Get(index);
}
inline void TensorProto::set_int32_data(int index, ::google::protobuf::int32 value) {
  int32_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:TensorProto.int32_data)
}
inline void TensorProto::add_int32_data(::google::protobuf::int32 value) {
  int32_data_.Add(value);
  // @@protoc_insertion_point(field_add:TensorProto.int32_data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorProto::int32_data() const {
  // @@protoc_insertion_point(field_list:TensorProto.int32_data)
  return int32_data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorProto::mutable_int32_data() {
  // @@protoc_insertion_point(field_mutable_list:TensorProto.int32_data)
  return &int32_data_;
}

// optional bytes byte_data = 5;
inline bool TensorProto::has_byte_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TensorProto::set_has_byte_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TensorProto::clear_has_byte_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TensorProto::clear_byte_data() {
  if (byte_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    byte_data_->clear();
  }
  clear_has_byte_data();
}
inline const ::std::string& TensorProto::byte_data() const {
  // @@protoc_insertion_point(field_get:TensorProto.byte_data)
  return *byte_data_;
}
inline void TensorProto::set_byte_data(const ::std::string& value) {
  set_has_byte_data();
  if (byte_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    byte_data_ = new ::std::string;
  }
  byte_data_->assign(value);
  // @@protoc_insertion_point(field_set:TensorProto.byte_data)
}
inline void TensorProto::set_byte_data(const char* value) {
  set_has_byte_data();
  if (byte_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    byte_data_ = new ::std::string;
  }
  byte_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:TensorProto.byte_data)
}
inline void TensorProto::set_byte_data(const void* value, size_t size) {
  set_has_byte_data();
  if (byte_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    byte_data_ = new ::std::string;
  }
  byte_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TensorProto.byte_data)
}
inline ::std::string* TensorProto::mutable_byte_data() {
  set_has_byte_data();
  if (byte_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    byte_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TensorProto.byte_data)
  return byte_data_;
}
inline ::std::string* TensorProto::release_byte_data() {
  clear_has_byte_data();
  if (byte_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = byte_data_;
    byte_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TensorProto::set_allocated_byte_data(::std::string* byte_data) {
  if (byte_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete byte_data_;
  }
  if (byte_data) {
    set_has_byte_data();
    byte_data_ = byte_data;
  } else {
    clear_has_byte_data();
    byte_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TensorProto.byte_data)
}

// repeated bytes string_data = 6;
inline int TensorProto::string_data_size() const {
  return string_data_.size();
}
inline void TensorProto::clear_string_data() {
  string_data_.Clear();
}
inline const ::std::string& TensorProto::string_data(int index) const {
  // @@protoc_insertion_point(field_get:TensorProto.string_data)
  return string_data_.Get(index);
}
inline ::std::string* TensorProto::mutable_string_data(int index) {
  // @@protoc_insertion_point(field_mutable:TensorProto.string_data)
  return string_data_.Mutable(index);
}
inline void TensorProto::set_string_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TensorProto.string_data)
  string_data_.Mutable(index)->assign(value);
}
inline void TensorProto::set_string_data(int index, const char* value) {
  string_data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TensorProto.string_data)
}
inline void TensorProto::set_string_data(int index, const void* value, size_t size) {
  string_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TensorProto.string_data)
}
inline ::std::string* TensorProto::add_string_data() {
  return string_data_.Add();
}
inline void TensorProto::add_string_data(const ::std::string& value) {
  string_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TensorProto.string_data)
}
inline void TensorProto::add_string_data(const char* value) {
  string_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TensorProto.string_data)
}
inline void TensorProto::add_string_data(const void* value, size_t size) {
  string_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TensorProto.string_data)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TensorProto::string_data() const {
  // @@protoc_insertion_point(field_list:TensorProto.string_data)
  return string_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TensorProto::mutable_string_data() {
  // @@protoc_insertion_point(field_mutable_list:TensorProto.string_data)
  return &string_data_;
}

// optional string name = 7;
inline bool TensorProto::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TensorProto::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TensorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TensorProto::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TensorProto::name() const {
  // @@protoc_insertion_point(field_get:TensorProto.name)
  return *name_;
}
inline void TensorProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:TensorProto.name)
}
inline void TensorProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:TensorProto.name)
}
inline void TensorProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TensorProto.name)
}
inline ::std::string* TensorProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TensorProto.name)
  return name_;
}
inline ::std::string* TensorProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TensorProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TensorProto.name)
}

// -------------------------------------------------------------------

// TensorProtos

// repeated .TensorProto protos = 1;
inline int TensorProtos::protos_size() const {
  return protos_.size();
}
inline void TensorProtos::clear_protos() {
  protos_.Clear();
}
inline const ::TensorProto& TensorProtos::protos(int index) const {
  // @@protoc_insertion_point(field_get:TensorProtos.protos)
  return protos_.Get(index);
}
inline ::TensorProto* TensorProtos::mutable_protos(int index) {
  // @@protoc_insertion_point(field_mutable:TensorProtos.protos)
  return protos_.Mutable(index);
}
inline ::TensorProto* TensorProtos::add_protos() {
  // @@protoc_insertion_point(field_add:TensorProtos.protos)
  return protos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TensorProto >&
TensorProtos::protos() const {
  // @@protoc_insertion_point(field_list:TensorProtos.protos)
  return protos_;
}
inline ::google::protobuf::RepeatedPtrField< ::TensorProto >*
TensorProtos::mutable_protos() {
  // @@protoc_insertion_point(field_mutable_list:TensorProtos.protos)
  return &protos_;
}

// -------------------------------------------------------------------

// Argument

// optional string name = 1;
inline bool Argument::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Argument::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Argument::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Argument::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:Argument.name)
  return *name_;
}
inline void Argument::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Argument.name)
}
inline void Argument::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Argument.name)
}
inline void Argument::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Argument.name)
}
inline ::std::string* Argument::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Argument.name)
  return name_;
}
inline ::std::string* Argument::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Argument::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Argument.name)
}

// optional float f = 2;
inline bool Argument::has_f() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Argument::set_has_f() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Argument::clear_has_f() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Argument::clear_f() {
  f_ = 0;
  clear_has_f();
}
inline float Argument::f() const {
  // @@protoc_insertion_point(field_get:Argument.f)
  return f_;
}
inline void Argument::set_f(float value) {
  set_has_f();
  f_ = value;
  // @@protoc_insertion_point(field_set:Argument.f)
}

// optional int32 i = 3;
inline bool Argument::has_i() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Argument::set_has_i() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Argument::clear_has_i() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Argument::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline ::google::protobuf::int32 Argument::i() const {
  // @@protoc_insertion_point(field_get:Argument.i)
  return i_;
}
inline void Argument::set_i(::google::protobuf::int32 value) {
  set_has_i();
  i_ = value;
  // @@protoc_insertion_point(field_set:Argument.i)
}

// optional int64 i64 = 9;
inline bool Argument::has_i64() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Argument::set_has_i64() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Argument::clear_has_i64() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Argument::clear_i64() {
  i64_ = GOOGLE_LONGLONG(0);
  clear_has_i64();
}
inline ::google::protobuf::int64 Argument::i64() const {
  // @@protoc_insertion_point(field_get:Argument.i64)
  return i64_;
}
inline void Argument::set_i64(::google::protobuf::int64 value) {
  set_has_i64();
  i64_ = value;
  // @@protoc_insertion_point(field_set:Argument.i64)
}

// optional string s = 4;
inline bool Argument::has_s() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Argument::set_has_s() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Argument::clear_has_s() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Argument::clear_s() {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& Argument::s() const {
  // @@protoc_insertion_point(field_get:Argument.s)
  return *s_;
}
inline void Argument::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set:Argument.s)
}
inline void Argument::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(value);
  // @@protoc_insertion_point(field_set_char:Argument.s)
}
inline void Argument::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Argument.s)
}
inline ::std::string* Argument::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Argument.s)
  return s_;
}
inline ::std::string* Argument::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Argument::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Argument.s)
}

// optional bool b = 8;
inline bool Argument::has_b() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Argument::set_has_b() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Argument::clear_has_b() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Argument::clear_b() {
  b_ = false;
  clear_has_b();
}
inline bool Argument::b() const {
  // @@protoc_insertion_point(field_get:Argument.b)
  return b_;
}
inline void Argument::set_b(bool value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:Argument.b)
}

// repeated float floats = 5;
inline int Argument::floats_size() const {
  return floats_.size();
}
inline void Argument::clear_floats() {
  floats_.Clear();
}
inline float Argument::floats(int index) const {
  // @@protoc_insertion_point(field_get:Argument.floats)
  return floats_.Get(index);
}
inline void Argument::set_floats(int index, float value) {
  floats_.Set(index, value);
  // @@protoc_insertion_point(field_set:Argument.floats)
}
inline void Argument::add_floats(float value) {
  floats_.Add(value);
  // @@protoc_insertion_point(field_add:Argument.floats)
}
inline const ::google::protobuf::RepeatedField< float >&
Argument::floats() const {
  // @@protoc_insertion_point(field_list:Argument.floats)
  return floats_;
}
inline ::google::protobuf::RepeatedField< float >*
Argument::mutable_floats() {
  // @@protoc_insertion_point(field_mutable_list:Argument.floats)
  return &floats_;
}

// repeated int32 ints = 6;
inline int Argument::ints_size() const {
  return ints_.size();
}
inline void Argument::clear_ints() {
  ints_.Clear();
}
inline ::google::protobuf::int32 Argument::ints(int index) const {
  // @@protoc_insertion_point(field_get:Argument.ints)
  return ints_.Get(index);
}
inline void Argument::set_ints(int index, ::google::protobuf::int32 value) {
  ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:Argument.ints)
}
inline void Argument::add_ints(::google::protobuf::int32 value) {
  ints_.Add(value);
  // @@protoc_insertion_point(field_add:Argument.ints)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Argument::ints() const {
  // @@protoc_insertion_point(field_list:Argument.ints)
  return ints_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Argument::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:Argument.ints)
  return &ints_;
}

// repeated string strings = 7;
inline int Argument::strings_size() const {
  return strings_.size();
}
inline void Argument::clear_strings() {
  strings_.Clear();
}
inline const ::std::string& Argument::strings(int index) const {
  // @@protoc_insertion_point(field_get:Argument.strings)
  return strings_.Get(index);
}
inline ::std::string* Argument::mutable_strings(int index) {
  // @@protoc_insertion_point(field_mutable:Argument.strings)
  return strings_.Mutable(index);
}
inline void Argument::set_strings(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Argument.strings)
  strings_.Mutable(index)->assign(value);
}
inline void Argument::set_strings(int index, const char* value) {
  strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Argument.strings)
}
inline void Argument::set_strings(int index, const char* value, size_t size) {
  strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Argument.strings)
}
inline ::std::string* Argument::add_strings() {
  return strings_.Add();
}
inline void Argument::add_strings(const ::std::string& value) {
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Argument.strings)
}
inline void Argument::add_strings(const char* value) {
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Argument.strings)
}
inline void Argument::add_strings(const char* value, size_t size) {
  strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Argument.strings)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Argument::strings() const {
  // @@protoc_insertion_point(field_list:Argument.strings)
  return strings_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Argument::mutable_strings() {
  // @@protoc_insertion_point(field_mutable_list:Argument.strings)
  return &strings_;
}

// -------------------------------------------------------------------

// DeviceOption

// optional .DeviceType device_type = 1 [default = CPU];
inline bool DeviceOption::has_device_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceOption::set_has_device_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceOption::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceOption::clear_device_type() {
  device_type_ = 0;
  clear_has_device_type();
}
inline ::DeviceType DeviceOption::device_type() const {
  // @@protoc_insertion_point(field_get:DeviceOption.device_type)
  return static_cast< ::DeviceType >(device_type_);
}
inline void DeviceOption::set_device_type(::DeviceType value) {
  assert(::DeviceType_IsValid(value));
  set_has_device_type();
  device_type_ = value;
  // @@protoc_insertion_point(field_set:DeviceOption.device_type)
}

// optional int32 gpu_id = 2 [default = 0];
inline bool DeviceOption::has_gpu_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceOption::set_has_gpu_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceOption::clear_has_gpu_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceOption::clear_gpu_id() {
  gpu_id_ = 0;
  clear_has_gpu_id();
}
inline ::google::protobuf::int32 DeviceOption::gpu_id() const {
  // @@protoc_insertion_point(field_get:DeviceOption.gpu_id)
  return gpu_id_;
}
inline void DeviceOption::set_gpu_id(::google::protobuf::int32 value) {
  set_has_gpu_id();
  gpu_id_ = value;
  // @@protoc_insertion_point(field_set:DeviceOption.gpu_id)
}

// optional uint32 random_seed = 3 [default = 3];
inline bool DeviceOption::has_random_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceOption::set_has_random_seed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceOption::clear_has_random_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceOption::clear_random_seed() {
  random_seed_ = 3u;
  clear_has_random_seed();
}
inline ::google::protobuf::uint32 DeviceOption::random_seed() const {
  // @@protoc_insertion_point(field_get:DeviceOption.random_seed)
  return random_seed_;
}
inline void DeviceOption::set_random_seed(::google::protobuf::uint32 value) {
  set_has_random_seed();
  random_seed_ = value;
  // @@protoc_insertion_point(field_set:DeviceOption.random_seed)
}

// optional string engine = 4;
inline bool DeviceOption::has_engine() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceOption::set_has_engine() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceOption::clear_has_engine() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceOption::clear_engine() {
  if (engine_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    engine_->clear();
  }
  clear_has_engine();
}
inline const ::std::string& DeviceOption::engine() const {
  // @@protoc_insertion_point(field_get:DeviceOption.engine)
  return *engine_;
}
inline void DeviceOption::set_engine(const ::std::string& value) {
  set_has_engine();
  if (engine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    engine_ = new ::std::string;
  }
  engine_->assign(value);
  // @@protoc_insertion_point(field_set:DeviceOption.engine)
}
inline void DeviceOption::set_engine(const char* value) {
  set_has_engine();
  if (engine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    engine_ = new ::std::string;
  }
  engine_->assign(value);
  // @@protoc_insertion_point(field_set_char:DeviceOption.engine)
}
inline void DeviceOption::set_engine(const char* value, size_t size) {
  set_has_engine();
  if (engine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    engine_ = new ::std::string;
  }
  engine_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DeviceOption.engine)
}
inline ::std::string* DeviceOption::mutable_engine() {
  set_has_engine();
  if (engine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    engine_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DeviceOption.engine)
  return engine_;
}
inline ::std::string* DeviceOption::release_engine() {
  clear_has_engine();
  if (engine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = engine_;
    engine_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceOption::set_allocated_engine(::std::string* engine) {
  if (engine_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete engine_;
  }
  if (engine) {
    set_has_engine();
    engine_ = engine;
  } else {
    clear_has_engine();
    engine_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DeviceOption.engine)
}

// -------------------------------------------------------------------

// OperatorDef

// repeated string input = 1;
inline int OperatorDef::input_size() const {
  return input_.size();
}
inline void OperatorDef::clear_input() {
  input_.Clear();
}
inline const ::std::string& OperatorDef::input(int index) const {
  // @@protoc_insertion_point(field_get:OperatorDef.input)
  return input_.Get(index);
}
inline ::std::string* OperatorDef::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:OperatorDef.input)
  return input_.Mutable(index);
}
inline void OperatorDef::set_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:OperatorDef.input)
  input_.Mutable(index)->assign(value);
}
inline void OperatorDef::set_input(int index, const char* value) {
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:OperatorDef.input)
}
inline void OperatorDef::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OperatorDef.input)
}
inline ::std::string* OperatorDef::add_input() {
  return input_.Add();
}
inline void OperatorDef::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:OperatorDef.input)
}
inline void OperatorDef::add_input(const char* value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:OperatorDef.input)
}
inline void OperatorDef::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:OperatorDef.input)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::input() const {
  // @@protoc_insertion_point(field_list:OperatorDef.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:OperatorDef.input)
  return &input_;
}

// repeated string output = 2;
inline int OperatorDef::output_size() const {
  return output_.size();
}
inline void OperatorDef::clear_output() {
  output_.Clear();
}
inline const ::std::string& OperatorDef::output(int index) const {
  // @@protoc_insertion_point(field_get:OperatorDef.output)
  return output_.Get(index);
}
inline ::std::string* OperatorDef::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:OperatorDef.output)
  return output_.Mutable(index);
}
inline void OperatorDef::set_output(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:OperatorDef.output)
  output_.Mutable(index)->assign(value);
}
inline void OperatorDef::set_output(int index, const char* value) {
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:OperatorDef.output)
}
inline void OperatorDef::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OperatorDef.output)
}
inline ::std::string* OperatorDef::add_output() {
  return output_.Add();
}
inline void OperatorDef::add_output(const ::std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:OperatorDef.output)
}
inline void OperatorDef::add_output(const char* value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:OperatorDef.output)
}
inline void OperatorDef::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:OperatorDef.output)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::output() const {
  // @@protoc_insertion_point(field_list:OperatorDef.output)
  return output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:OperatorDef.output)
  return &output_;
}

// optional string name = 3;
inline bool OperatorDef::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperatorDef::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperatorDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperatorDef::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OperatorDef::name() const {
  // @@protoc_insertion_point(field_get:OperatorDef.name)
  return *name_;
}
inline void OperatorDef::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:OperatorDef.name)
}
inline void OperatorDef::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:OperatorDef.name)
}
inline void OperatorDef::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OperatorDef.name)
}
inline ::std::string* OperatorDef::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OperatorDef.name)
  return name_;
}
inline ::std::string* OperatorDef::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OperatorDef::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OperatorDef.name)
}

// optional string type = 4;
inline bool OperatorDef::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperatorDef::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperatorDef::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperatorDef::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& OperatorDef::type() const {
  // @@protoc_insertion_point(field_get:OperatorDef.type)
  return *type_;
}
inline void OperatorDef::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:OperatorDef.type)
}
inline void OperatorDef::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:OperatorDef.type)
}
inline void OperatorDef::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OperatorDef.type)
}
inline ::std::string* OperatorDef::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OperatorDef.type)
  return type_;
}
inline ::std::string* OperatorDef::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OperatorDef::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OperatorDef.type)
}

// repeated .Argument arg = 5;
inline int OperatorDef::arg_size() const {
  return arg_.size();
}
inline void OperatorDef::clear_arg() {
  arg_.Clear();
}
inline const ::Argument& OperatorDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:OperatorDef.arg)
  return arg_.Get(index);
}
inline ::Argument* OperatorDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:OperatorDef.arg)
  return arg_.Mutable(index);
}
inline ::Argument* OperatorDef::add_arg() {
  // @@protoc_insertion_point(field_add:OperatorDef.arg)
  return arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Argument >&
OperatorDef::arg() const {
  // @@protoc_insertion_point(field_list:OperatorDef.arg)
  return arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::Argument >*
OperatorDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:OperatorDef.arg)
  return &arg_;
}

// optional .DeviceOption device_option = 6;
inline bool OperatorDef::has_device_option() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OperatorDef::set_has_device_option() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OperatorDef::clear_has_device_option() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OperatorDef::clear_device_option() {
  if (device_option_ != NULL) device_option_->::DeviceOption::Clear();
  clear_has_device_option();
}
inline const ::DeviceOption& OperatorDef::device_option() const {
  // @@protoc_insertion_point(field_get:OperatorDef.device_option)
  return device_option_ != NULL ? *device_option_ : *default_instance_->device_option_;
}
inline ::DeviceOption* OperatorDef::mutable_device_option() {
  set_has_device_option();
  if (device_option_ == NULL) device_option_ = new ::DeviceOption;
  // @@protoc_insertion_point(field_mutable:OperatorDef.device_option)
  return device_option_;
}
inline ::DeviceOption* OperatorDef::release_device_option() {
  clear_has_device_option();
  ::DeviceOption* temp = device_option_;
  device_option_ = NULL;
  return temp;
}
inline void OperatorDef::set_allocated_device_option(::DeviceOption* device_option) {
  delete device_option_;
  device_option_ = device_option;
  if (device_option) {
    set_has_device_option();
  } else {
    clear_has_device_option();
  }
  // @@protoc_insertion_point(field_set_allocated:OperatorDef.device_option)
}

// optional bool debug_mode = 7 [default = false];
inline bool OperatorDef::has_debug_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OperatorDef::set_has_debug_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OperatorDef::clear_has_debug_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OperatorDef::clear_debug_mode() {
  debug_mode_ = false;
  clear_has_debug_mode();
}
inline bool OperatorDef::debug_mode() const {
  // @@protoc_insertion_point(field_get:OperatorDef.debug_mode)
  return debug_mode_;
}
inline void OperatorDef::set_debug_mode(bool value) {
  set_has_debug_mode();
  debug_mode_ = value;
  // @@protoc_insertion_point(field_set:OperatorDef.debug_mode)
}

// optional bool share_grads = 8 [default = false];
inline bool OperatorDef::has_share_grads() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OperatorDef::set_has_share_grads() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OperatorDef::clear_has_share_grads() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OperatorDef::clear_share_grads() {
  share_grads_ = false;
  clear_has_share_grads();
}
inline bool OperatorDef::share_grads() const {
  // @@protoc_insertion_point(field_get:OperatorDef.share_grads)
  return share_grads_;
}
inline void OperatorDef::set_share_grads(bool value) {
  set_has_share_grads();
  share_grads_ = value;
  // @@protoc_insertion_point(field_set:OperatorDef.share_grads)
}

// -------------------------------------------------------------------

// GradientTarget

// optional string cost = 1;
inline bool GradientTarget::has_cost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GradientTarget::set_has_cost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GradientTarget::clear_has_cost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GradientTarget::clear_cost() {
  if (cost_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cost_->clear();
  }
  clear_has_cost();
}
inline const ::std::string& GradientTarget::cost() const {
  // @@protoc_insertion_point(field_get:GradientTarget.cost)
  return *cost_;
}
inline void GradientTarget::set_cost(const ::std::string& value) {
  set_has_cost();
  if (cost_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cost_ = new ::std::string;
  }
  cost_->assign(value);
  // @@protoc_insertion_point(field_set:GradientTarget.cost)
}
inline void GradientTarget::set_cost(const char* value) {
  set_has_cost();
  if (cost_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cost_ = new ::std::string;
  }
  cost_->assign(value);
  // @@protoc_insertion_point(field_set_char:GradientTarget.cost)
}
inline void GradientTarget::set_cost(const char* value, size_t size) {
  set_has_cost();
  if (cost_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cost_ = new ::std::string;
  }
  cost_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GradientTarget.cost)
}
inline ::std::string* GradientTarget::mutable_cost() {
  set_has_cost();
  if (cost_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cost_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GradientTarget.cost)
  return cost_;
}
inline ::std::string* GradientTarget::release_cost() {
  clear_has_cost();
  if (cost_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cost_;
    cost_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GradientTarget::set_allocated_cost(::std::string* cost) {
  if (cost_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cost_;
  }
  if (cost) {
    set_has_cost();
    cost_ = cost;
  } else {
    clear_has_cost();
    cost_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GradientTarget.cost)
}

// optional string wrt = 2;
inline bool GradientTarget::has_wrt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GradientTarget::set_has_wrt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GradientTarget::clear_has_wrt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GradientTarget::clear_wrt() {
  if (wrt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wrt_->clear();
  }
  clear_has_wrt();
}
inline const ::std::string& GradientTarget::wrt() const {
  // @@protoc_insertion_point(field_get:GradientTarget.wrt)
  return *wrt_;
}
inline void GradientTarget::set_wrt(const ::std::string& value) {
  set_has_wrt();
  if (wrt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wrt_ = new ::std::string;
  }
  wrt_->assign(value);
  // @@protoc_insertion_point(field_set:GradientTarget.wrt)
}
inline void GradientTarget::set_wrt(const char* value) {
  set_has_wrt();
  if (wrt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wrt_ = new ::std::string;
  }
  wrt_->assign(value);
  // @@protoc_insertion_point(field_set_char:GradientTarget.wrt)
}
inline void GradientTarget::set_wrt(const char* value, size_t size) {
  set_has_wrt();
  if (wrt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wrt_ = new ::std::string;
  }
  wrt_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GradientTarget.wrt)
}
inline ::std::string* GradientTarget::mutable_wrt() {
  set_has_wrt();
  if (wrt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wrt_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GradientTarget.wrt)
  return wrt_;
}
inline ::std::string* GradientTarget::release_wrt() {
  clear_has_wrt();
  if (wrt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = wrt_;
    wrt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GradientTarget::set_allocated_wrt(::std::string* wrt) {
  if (wrt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete wrt_;
  }
  if (wrt) {
    set_has_wrt();
    wrt_ = wrt;
  } else {
    clear_has_wrt();
    wrt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GradientTarget.wrt)
}

// optional string external = 3;
inline bool GradientTarget::has_external() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GradientTarget::set_has_external() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GradientTarget::clear_has_external() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GradientTarget::clear_external() {
  if (external_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    external_->clear();
  }
  clear_has_external();
}
inline const ::std::string& GradientTarget::external() const {
  // @@protoc_insertion_point(field_get:GradientTarget.external)
  return *external_;
}
inline void GradientTarget::set_external(const ::std::string& value) {
  set_has_external();
  if (external_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    external_ = new ::std::string;
  }
  external_->assign(value);
  // @@protoc_insertion_point(field_set:GradientTarget.external)
}
inline void GradientTarget::set_external(const char* value) {
  set_has_external();
  if (external_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    external_ = new ::std::string;
  }
  external_->assign(value);
  // @@protoc_insertion_point(field_set_char:GradientTarget.external)
}
inline void GradientTarget::set_external(const char* value, size_t size) {
  set_has_external();
  if (external_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    external_ = new ::std::string;
  }
  external_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GradientTarget.external)
}
inline ::std::string* GradientTarget::mutable_external() {
  set_has_external();
  if (external_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    external_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GradientTarget.external)
  return external_;
}
inline ::std::string* GradientTarget::release_external() {
  clear_has_external();
  if (external_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = external_;
    external_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GradientTarget::set_allocated_external(::std::string* external) {
  if (external_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete external_;
  }
  if (external) {
    set_has_external();
    external_ = external;
  } else {
    clear_has_external();
    external_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GradientTarget.external)
}

// -------------------------------------------------------------------

// UpdateTarget

// optional string name = 1;
inline bool UpdateTarget::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTarget::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTarget::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTarget::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UpdateTarget::name() const {
  // @@protoc_insertion_point(field_get:UpdateTarget.name)
  return *name_;
}
inline void UpdateTarget::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:UpdateTarget.name)
}
inline void UpdateTarget::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:UpdateTarget.name)
}
inline void UpdateTarget::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UpdateTarget.name)
}
inline ::std::string* UpdateTarget::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UpdateTarget.name)
  return name_;
}
inline ::std::string* UpdateTarget::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateTarget::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UpdateTarget.name)
}

// optional string type = 2;
inline bool UpdateTarget::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTarget::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTarget::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTarget::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& UpdateTarget::type() const {
  // @@protoc_insertion_point(field_get:UpdateTarget.type)
  return *type_;
}
inline void UpdateTarget::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:UpdateTarget.type)
}
inline void UpdateTarget::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:UpdateTarget.type)
}
inline void UpdateTarget::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UpdateTarget.type)
}
inline ::std::string* UpdateTarget::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UpdateTarget.type)
  return type_;
}
inline ::std::string* UpdateTarget::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateTarget::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UpdateTarget.type)
}

// repeated string tensor = 3;
inline int UpdateTarget::tensor_size() const {
  return tensor_.size();
}
inline void UpdateTarget::clear_tensor() {
  tensor_.Clear();
}
inline const ::std::string& UpdateTarget::tensor(int index) const {
  // @@protoc_insertion_point(field_get:UpdateTarget.tensor)
  return tensor_.Get(index);
}
inline ::std::string* UpdateTarget::mutable_tensor(int index) {
  // @@protoc_insertion_point(field_mutable:UpdateTarget.tensor)
  return tensor_.Mutable(index);
}
inline void UpdateTarget::set_tensor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:UpdateTarget.tensor)
  tensor_.Mutable(index)->assign(value);
}
inline void UpdateTarget::set_tensor(int index, const char* value) {
  tensor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:UpdateTarget.tensor)
}
inline void UpdateTarget::set_tensor(int index, const char* value, size_t size) {
  tensor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UpdateTarget.tensor)
}
inline ::std::string* UpdateTarget::add_tensor() {
  return tensor_.Add();
}
inline void UpdateTarget::add_tensor(const ::std::string& value) {
  tensor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:UpdateTarget.tensor)
}
inline void UpdateTarget::add_tensor(const char* value) {
  tensor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:UpdateTarget.tensor)
}
inline void UpdateTarget::add_tensor(const char* value, size_t size) {
  tensor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:UpdateTarget.tensor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UpdateTarget::tensor() const {
  // @@protoc_insertion_point(field_list:UpdateTarget.tensor)
  return tensor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UpdateTarget::mutable_tensor() {
  // @@protoc_insertion_point(field_mutable_list:UpdateTarget.tensor)
  return &tensor_;
}

// repeated .Argument arg = 4;
inline int UpdateTarget::arg_size() const {
  return arg_.size();
}
inline void UpdateTarget::clear_arg() {
  arg_.Clear();
}
inline const ::Argument& UpdateTarget::arg(int index) const {
  // @@protoc_insertion_point(field_get:UpdateTarget.arg)
  return arg_.Get(index);
}
inline ::Argument* UpdateTarget::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:UpdateTarget.arg)
  return arg_.Mutable(index);
}
inline ::Argument* UpdateTarget::add_arg() {
  // @@protoc_insertion_point(field_add:UpdateTarget.arg)
  return arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Argument >&
UpdateTarget::arg() const {
  // @@protoc_insertion_point(field_list:UpdateTarget.arg)
  return arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::Argument >*
UpdateTarget::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:UpdateTarget.arg)
  return &arg_;
}

// -------------------------------------------------------------------

// TensorFiller

// optional string tensor = 1;
inline bool TensorFiller::has_tensor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TensorFiller::set_has_tensor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TensorFiller::clear_has_tensor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TensorFiller::clear_tensor() {
  if (tensor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tensor_->clear();
  }
  clear_has_tensor();
}
inline const ::std::string& TensorFiller::tensor() const {
  // @@protoc_insertion_point(field_get:TensorFiller.tensor)
  return *tensor_;
}
inline void TensorFiller::set_tensor(const ::std::string& value) {
  set_has_tensor();
  if (tensor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tensor_ = new ::std::string;
  }
  tensor_->assign(value);
  // @@protoc_insertion_point(field_set:TensorFiller.tensor)
}
inline void TensorFiller::set_tensor(const char* value) {
  set_has_tensor();
  if (tensor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tensor_ = new ::std::string;
  }
  tensor_->assign(value);
  // @@protoc_insertion_point(field_set_char:TensorFiller.tensor)
}
inline void TensorFiller::set_tensor(const char* value, size_t size) {
  set_has_tensor();
  if (tensor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tensor_ = new ::std::string;
  }
  tensor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TensorFiller.tensor)
}
inline ::std::string* TensorFiller::mutable_tensor() {
  set_has_tensor();
  if (tensor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tensor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TensorFiller.tensor)
  return tensor_;
}
inline ::std::string* TensorFiller::release_tensor() {
  clear_has_tensor();
  if (tensor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tensor_;
    tensor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TensorFiller::set_allocated_tensor(::std::string* tensor) {
  if (tensor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tensor_;
  }
  if (tensor) {
    set_has_tensor();
    tensor_ = tensor;
  } else {
    clear_has_tensor();
    tensor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TensorFiller.tensor)
}

// optional string type = 2 [default = "constant"];
inline bool TensorFiller::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TensorFiller::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TensorFiller::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TensorFiller::clear_type() {
  if (type_ != _default_type_) {
    type_->assign(*_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& TensorFiller::type() const {
  // @@protoc_insertion_point(field_get:TensorFiller.type)
  return *type_;
}
inline void TensorFiller::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:TensorFiller.type)
}
inline void TensorFiller::set_type(const char* value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:TensorFiller.type)
}
inline void TensorFiller::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TensorFiller.type)
}
inline ::std::string* TensorFiller::mutable_type() {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string(*_default_type_);
  }
  // @@protoc_insertion_point(field_mutable:TensorFiller.type)
  return type_;
}
inline ::std::string* TensorFiller::release_type() {
  clear_has_type();
  if (type_ == _default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(_default_type_);
    return temp;
  }
}
inline void TensorFiller::set_allocated_type(::std::string* type) {
  if (type_ != _default_type_) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(_default_type_);
  }
  // @@protoc_insertion_point(field_set_allocated:TensorFiller.type)
}

// optional float value = 3 [default = 0];
inline bool TensorFiller::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TensorFiller::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TensorFiller::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TensorFiller::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float TensorFiller::value() const {
  // @@protoc_insertion_point(field_get:TensorFiller.value)
  return value_;
}
inline void TensorFiller::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:TensorFiller.value)
}

// optional float low = 4 [default = 0];
inline bool TensorFiller::has_low() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TensorFiller::set_has_low() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TensorFiller::clear_has_low() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TensorFiller::clear_low() {
  low_ = 0;
  clear_has_low();
}
inline float TensorFiller::low() const {
  // @@protoc_insertion_point(field_get:TensorFiller.low)
  return low_;
}
inline void TensorFiller::set_low(float value) {
  set_has_low();
  low_ = value;
  // @@protoc_insertion_point(field_set:TensorFiller.low)
}

// optional float high = 5 [default = 1];
inline bool TensorFiller::has_high() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TensorFiller::set_has_high() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TensorFiller::clear_has_high() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TensorFiller::clear_high() {
  high_ = 1;
  clear_has_high();
}
inline float TensorFiller::high() const {
  // @@protoc_insertion_point(field_get:TensorFiller.high)
  return high_;
}
inline void TensorFiller::set_high(float value) {
  set_has_high();
  high_ = value;
  // @@protoc_insertion_point(field_set:TensorFiller.high)
}

// optional float mean = 6 [default = 0];
inline bool TensorFiller::has_mean() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TensorFiller::set_has_mean() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TensorFiller::clear_has_mean() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TensorFiller::clear_mean() {
  mean_ = 0;
  clear_has_mean();
}
inline float TensorFiller::mean() const {
  // @@protoc_insertion_point(field_get:TensorFiller.mean)
  return mean_;
}
inline void TensorFiller::set_mean(float value) {
  set_has_mean();
  mean_ = value;
  // @@protoc_insertion_point(field_set:TensorFiller.mean)
}

// optional float std = 7 [default = 1];
inline bool TensorFiller::has_std() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TensorFiller::set_has_std() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TensorFiller::clear_has_std() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TensorFiller::clear_std() {
  std_ = 1;
  clear_has_std();
}
inline float TensorFiller::std() const {
  // @@protoc_insertion_point(field_get:TensorFiller.std)
  return std_;
}
inline void TensorFiller::set_std(float value) {
  set_has_std();
  std_ = value;
  // @@protoc_insertion_point(field_set:TensorFiller.std)
}

// optional float scale = 8 [default = 3];
inline bool TensorFiller::has_scale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TensorFiller::set_has_scale() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TensorFiller::clear_has_scale() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TensorFiller::clear_scale() {
  scale_ = 3;
  clear_has_scale();
}
inline float TensorFiller::scale() const {
  // @@protoc_insertion_point(field_get:TensorFiller.scale)
  return scale_;
}
inline void TensorFiller::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:TensorFiller.scale)
}

// optional .TensorFiller.VarianceNorm variance_norm = 9 [default = FAN_IN];
inline bool TensorFiller::has_variance_norm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TensorFiller::set_has_variance_norm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TensorFiller::clear_has_variance_norm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TensorFiller::clear_variance_norm() {
  variance_norm_ = 0;
  clear_has_variance_norm();
}
inline ::TensorFiller_VarianceNorm TensorFiller::variance_norm() const {
  // @@protoc_insertion_point(field_get:TensorFiller.variance_norm)
  return static_cast< ::TensorFiller_VarianceNorm >(variance_norm_);
}
inline void TensorFiller::set_variance_norm(::TensorFiller_VarianceNorm value) {
  assert(::TensorFiller_VarianceNorm_IsValid(value));
  set_has_variance_norm();
  variance_norm_ = value;
  // @@protoc_insertion_point(field_set:TensorFiller.variance_norm)
}

// -------------------------------------------------------------------

// GraphDef

// optional string name = 1;
inline bool GraphDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GraphDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GraphDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GraphDef::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GraphDef::name() const {
  // @@protoc_insertion_point(field_get:GraphDef.name)
  return *name_;
}
inline void GraphDef::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:GraphDef.name)
}
inline void GraphDef::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:GraphDef.name)
}
inline void GraphDef::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GraphDef.name)
}
inline ::std::string* GraphDef::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GraphDef.name)
  return name_;
}
inline ::std::string* GraphDef::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GraphDef::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GraphDef.name)
}

// repeated .OperatorDef op = 2;
inline int GraphDef::op_size() const {
  return op_.size();
}
inline void GraphDef::clear_op() {
  op_.Clear();
}
inline const ::OperatorDef& GraphDef::op(int index) const {
  // @@protoc_insertion_point(field_get:GraphDef.op)
  return op_.Get(index);
}
inline ::OperatorDef* GraphDef::mutable_op(int index) {
  // @@protoc_insertion_point(field_mutable:GraphDef.op)
  return op_.Mutable(index);
}
inline ::OperatorDef* GraphDef::add_op() {
  // @@protoc_insertion_point(field_add:GraphDef.op)
  return op_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OperatorDef >&
GraphDef::op() const {
  // @@protoc_insertion_point(field_list:GraphDef.op)
  return op_;
}
inline ::google::protobuf::RepeatedPtrField< ::OperatorDef >*
GraphDef::mutable_op() {
  // @@protoc_insertion_point(field_mutable_list:GraphDef.op)
  return &op_;
}

// optional string graph_type = 3;
inline bool GraphDef::has_graph_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GraphDef::set_has_graph_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GraphDef::clear_has_graph_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GraphDef::clear_graph_type() {
  if (graph_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graph_type_->clear();
  }
  clear_has_graph_type();
}
inline const ::std::string& GraphDef::graph_type() const {
  // @@protoc_insertion_point(field_get:GraphDef.graph_type)
  return *graph_type_;
}
inline void GraphDef::set_graph_type(const ::std::string& value) {
  set_has_graph_type();
  if (graph_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graph_type_ = new ::std::string;
  }
  graph_type_->assign(value);
  // @@protoc_insertion_point(field_set:GraphDef.graph_type)
}
inline void GraphDef::set_graph_type(const char* value) {
  set_has_graph_type();
  if (graph_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graph_type_ = new ::std::string;
  }
  graph_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:GraphDef.graph_type)
}
inline void GraphDef::set_graph_type(const char* value, size_t size) {
  set_has_graph_type();
  if (graph_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graph_type_ = new ::std::string;
  }
  graph_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GraphDef.graph_type)
}
inline ::std::string* GraphDef::mutable_graph_type() {
  set_has_graph_type();
  if (graph_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graph_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GraphDef.graph_type)
  return graph_type_;
}
inline ::std::string* GraphDef::release_graph_type() {
  clear_has_graph_type();
  if (graph_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = graph_type_;
    graph_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GraphDef::set_allocated_graph_type(::std::string* graph_type) {
  if (graph_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete graph_type_;
  }
  if (graph_type) {
    set_has_graph_type();
    graph_type_ = graph_type;
  } else {
    clear_has_graph_type();
    graph_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GraphDef.graph_type)
}

// optional .DeviceOption device_option = 5;
inline bool GraphDef::has_device_option() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GraphDef::set_has_device_option() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GraphDef::clear_has_device_option() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GraphDef::clear_device_option() {
  if (device_option_ != NULL) device_option_->::DeviceOption::Clear();
  clear_has_device_option();
}
inline const ::DeviceOption& GraphDef::device_option() const {
  // @@protoc_insertion_point(field_get:GraphDef.device_option)
  return device_option_ != NULL ? *device_option_ : *default_instance_->device_option_;
}
inline ::DeviceOption* GraphDef::mutable_device_option() {
  set_has_device_option();
  if (device_option_ == NULL) device_option_ = new ::DeviceOption;
  // @@protoc_insertion_point(field_mutable:GraphDef.device_option)
  return device_option_;
}
inline ::DeviceOption* GraphDef::release_device_option() {
  clear_has_device_option();
  ::DeviceOption* temp = device_option_;
  device_option_ = NULL;
  return temp;
}
inline void GraphDef::set_allocated_device_option(::DeviceOption* device_option) {
  delete device_option_;
  device_option_ = device_option;
  if (device_option) {
    set_has_device_option();
  } else {
    clear_has_device_option();
  }
  // @@protoc_insertion_point(field_set_allocated:GraphDef.device_option)
}

// repeated .Argument arg = 6;
inline int GraphDef::arg_size() const {
  return arg_.size();
}
inline void GraphDef::clear_arg() {
  arg_.Clear();
}
inline const ::Argument& GraphDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:GraphDef.arg)
  return arg_.Get(index);
}
inline ::Argument* GraphDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:GraphDef.arg)
  return arg_.Mutable(index);
}
inline ::Argument* GraphDef::add_arg() {
  // @@protoc_insertion_point(field_add:GraphDef.arg)
  return arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Argument >&
GraphDef::arg() const {
  // @@protoc_insertion_point(field_list:GraphDef.arg)
  return arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::Argument >*
GraphDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:GraphDef.arg)
  return &arg_;
}

// repeated string target = 7;
inline int GraphDef::target_size() const {
  return target_.size();
}
inline void GraphDef::clear_target() {
  target_.Clear();
}
inline const ::std::string& GraphDef::target(int index) const {
  // @@protoc_insertion_point(field_get:GraphDef.target)
  return target_.Get(index);
}
inline ::std::string* GraphDef::mutable_target(int index) {
  // @@protoc_insertion_point(field_mutable:GraphDef.target)
  return target_.Mutable(index);
}
inline void GraphDef::set_target(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:GraphDef.target)
  target_.Mutable(index)->assign(value);
}
inline void GraphDef::set_target(int index, const char* value) {
  target_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GraphDef.target)
}
inline void GraphDef::set_target(int index, const char* value, size_t size) {
  target_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GraphDef.target)
}
inline ::std::string* GraphDef::add_target() {
  return target_.Add();
}
inline void GraphDef::add_target(const ::std::string& value) {
  target_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GraphDef.target)
}
inline void GraphDef::add_target(const char* value) {
  target_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GraphDef.target)
}
inline void GraphDef::add_target(const char* value, size_t size) {
  target_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GraphDef.target)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GraphDef::target() const {
  // @@protoc_insertion_point(field_list:GraphDef.target)
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GraphDef::mutable_target() {
  // @@protoc_insertion_point(field_mutable_list:GraphDef.target)
  return &target_;
}

// repeated .GradientTarget g_target = 8;
inline int GraphDef::g_target_size() const {
  return g_target_.size();
}
inline void GraphDef::clear_g_target() {
  g_target_.Clear();
}
inline const ::GradientTarget& GraphDef::g_target(int index) const {
  // @@protoc_insertion_point(field_get:GraphDef.g_target)
  return g_target_.Get(index);
}
inline ::GradientTarget* GraphDef::mutable_g_target(int index) {
  // @@protoc_insertion_point(field_mutable:GraphDef.g_target)
  return g_target_.Mutable(index);
}
inline ::GradientTarget* GraphDef::add_g_target() {
  // @@protoc_insertion_point(field_add:GraphDef.g_target)
  return g_target_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GradientTarget >&
GraphDef::g_target() const {
  // @@protoc_insertion_point(field_list:GraphDef.g_target)
  return g_target_;
}
inline ::google::protobuf::RepeatedPtrField< ::GradientTarget >*
GraphDef::mutable_g_target() {
  // @@protoc_insertion_point(field_mutable_list:GraphDef.g_target)
  return &g_target_;
}

// repeated .UpdateTarget u_target = 9;
inline int GraphDef::u_target_size() const {
  return u_target_.size();
}
inline void GraphDef::clear_u_target() {
  u_target_.Clear();
}
inline const ::UpdateTarget& GraphDef::u_target(int index) const {
  // @@protoc_insertion_point(field_get:GraphDef.u_target)
  return u_target_.Get(index);
}
inline ::UpdateTarget* GraphDef::mutable_u_target(int index) {
  // @@protoc_insertion_point(field_mutable:GraphDef.u_target)
  return u_target_.Mutable(index);
}
inline ::UpdateTarget* GraphDef::add_u_target() {
  // @@protoc_insertion_point(field_add:GraphDef.u_target)
  return u_target_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UpdateTarget >&
GraphDef::u_target() const {
  // @@protoc_insertion_point(field_list:GraphDef.u_target)
  return u_target_;
}
inline ::google::protobuf::RepeatedPtrField< ::UpdateTarget >*
GraphDef::mutable_u_target() {
  // @@protoc_insertion_point(field_mutable_list:GraphDef.u_target)
  return &u_target_;
}

// optional bool debug_mode = 10 [default = false];
inline bool GraphDef::has_debug_mode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GraphDef::set_has_debug_mode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GraphDef::clear_has_debug_mode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GraphDef::clear_debug_mode() {
  debug_mode_ = false;
  clear_has_debug_mode();
}
inline bool GraphDef::debug_mode() const {
  // @@protoc_insertion_point(field_get:GraphDef.debug_mode)
  return debug_mode_;
}
inline void GraphDef::set_debug_mode(bool value) {
  set_has_debug_mode();
  debug_mode_ = value;
  // @@protoc_insertion_point(field_set:GraphDef.debug_mode)
}

// optional bool share_grads = 11 [default = false];
inline bool GraphDef::has_share_grads() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GraphDef::set_has_share_grads() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GraphDef::clear_has_share_grads() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GraphDef::clear_share_grads() {
  share_grads_ = false;
  clear_has_share_grads();
}
inline bool GraphDef::share_grads() const {
  // @@protoc_insertion_point(field_get:GraphDef.share_grads)
  return share_grads_;
}
inline void GraphDef::set_share_grads(bool value) {
  set_has_share_grads();
  share_grads_ = value;
  // @@protoc_insertion_point(field_set:GraphDef.share_grads)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::TensorProto_DataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TensorProto_DataType>() {
  return ::TensorProto_DataType_descriptor();
}
template <> struct is_proto_enum< ::TensorFiller_VarianceNorm> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TensorFiller_VarianceNorm>() {
  return ::TensorFiller_VarianceNorm_descriptor();
}
template <> struct is_proto_enum< ::DeviceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DeviceType>() {
  return ::DeviceType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dragon_2eproto__INCLUDED
